<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®åˆ†æ - Queryè¯„åˆ†ä¸å­—æ•°å…³ç³»</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            color: #667eea;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .upload-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .file-name {
            color: #666;
            font-size: 14px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 16px;
            margin-bottom: 30px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results {
            display: none;
        }

        .results.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
        }

        .stat-value {
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        .chart-section {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        .chart-section h2 {
            color: #667eea;
            font-size: 24px;
            margin-bottom: 20px;
        }

        .chart-container {
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
        }

        .insight {
            background: #f8f9ff;
            border-left: 4px solid #667eea;
            padding: 15px 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .insight-title {
            color: #667eea;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .insight-text {
            color: #666;
            line-height: 1.6;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .error.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š Queryè¯„åˆ†ä¸å­—æ•°å…³ç³»åˆ†æ</h1>
            <p style="color: #666; margin-bottom: 20px;">ä¸Šä¼ åŒ…å«"å­—æ•°ç»Ÿè®¡"å’Œ"èƒœç‡"ä¸¤ä¸ªsheetçš„Excelæ–‡ä»¶ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨è¿›è¡Œæ•°æ®åˆ†æå’Œå¯è§†åŒ–</p>
            
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls" />
                    <button class="file-input-button" onclick="document.getElementById('excelFile').click()">
                        ğŸ“ é€‰æ‹©Excelæ–‡ä»¶
                    </button>
                </div>
                <span id="fileName" class="file-name">æœªé€‰æ‹©æ–‡ä»¶</span>
            </div>
        </div>

        <div id="error" class="error"></div>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨åˆ†ææ•°æ®ï¼Œè¯·ç¨å€™...</p>
        </div>

        <div id="results" class="results">
            <!-- åŸºç¡€ç»Ÿè®¡ -->
            <div class="stats-grid" id="statsGrid"></div>

            <!-- å›¾è¡¨åŒºåŸŸ -->
            <div class="chart-section">
                <h2>å­—æ•°ä¸èƒœç‡å…³ç³»åˆ†æ</h2>
                <div id="scatterPlot" class="chart-container"></div>
                <div class="insight" id="correlationInsight"></div>
            </div>

            <div class="chart-section">
                <h2>æŒ‰å­—æ•°åŒºé—´çš„èƒœç‡åˆ†å¸ƒ</h2>
                <div id="boxPlot" class="chart-container"></div>
                <div class="insight" id="distributionInsight"></div>
            </div>

            <div class="chart-section">
                <h2>å˜é‡ç›¸å…³æ€§çƒ­åŠ›å›¾</h2>
                <div id="heatmap" class="chart-container"></div>
                <div class="insight" id="heatmapInsight"></div>
            </div>

            <div class="chart-section">
                <h2>ä¸åŒæ¨¡å‹çš„å¹³å‡è¡¨ç°å¯¹æ¯”</h2>
                <div id="modelComparison" class="chart-container"></div>
                <div class="insight" id="modelInsight"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
        document.getElementById('excelFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fileName').textContent = file.name;
                loadAndAnalyze(file);
            }
        });

        async function loadAndAnalyze(file) {
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            document.getElementById('loading').classList.add('active');
            document.getElementById('results').classList.remove('active');
            document.getElementById('error').classList.remove('active');

            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });

                // è¯»å–å­—æ•°ç»Ÿè®¡å’Œèƒœç‡sheet
                const charCountSheet = workbook.Sheets['å­—æ•°ç»Ÿè®¡'];
                const winRateSheet = workbook.Sheets['èƒœç‡'];

                if (!charCountSheet || !winRateSheet) {
                    throw new Error('Excelæ–‡ä»¶å¿…é¡»åŒ…å«"å­—æ•°ç»Ÿè®¡"å’Œ"èƒœç‡"ä¸¤ä¸ªsheet');
                }

                const charCountData = XLSX.utils.sheet_to_json(charCountSheet, { header: 1 });
                const winRateData = XLSX.utils.sheet_to_json(winRateSheet, { header: 1 });

                // è½¬æ¢ä¸ºé•¿æ ¼å¼æ•°æ®
                const tidyData = convertToTidyFormat(charCountData, winRateData);

                // æ‰§è¡Œåˆ†æ
                analyzeData(tidyData);

                // éšè—åŠ è½½ï¼Œæ˜¾ç¤ºç»“æœ
                document.getElementById('loading').classList.remove('active');
                document.getElementById('results').classList.add('active');

            } catch (error) {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('error').textContent = 'é”™è¯¯ï¼š' + error.message;
                document.getElementById('error').classList.add('active');
                console.error(error);
            }
        }

        function convertToTidyFormat(charCountData, winRateData) {
            const tidyData = [];
            
            // è·å–åˆ—åï¼ˆæ¨¡å‹åï¼‰
            const charHeaders = charCountData[0];
            const winHeaders = winRateData[0];

            // ä»ç¬¬äºŒè¡Œå¼€å§‹å¤„ç†æ•°æ®
            for (let i = 1; i < Math.max(charCountData.length, winRateData.length); i++) {
                const charRow = charCountData[i] || [];
                const winRow = winRateData[i] || [];
                
                const queryId = charRow[0] || winRow[0]; // ç¬¬ä¸€åˆ—æ˜¯queryç¼–å·

                // éå†æ¯ä¸ªæ¨¡å‹
                for (let j = 1; j < charHeaders.length; j++) {
                    const model = charHeaders[j];
                    const wordCount = charRow[j];
                    const winRateStr = winRow[j];

                    // åªæ·»åŠ æœ‰æ•°æ®çš„è®°å½•
                    if (wordCount || winRateStr) {
                        // è§£æèƒœç‡ç™¾åˆ†æ¯”
                        let rating = null;
                        if (winRateStr) {
                            const match = winRateStr.toString().match(/(\d+\.?\d*)%/);
                            rating = match ? parseFloat(match[1]) : null;
                        }

                        tidyData.push({
                            query: queryId,
                            model: model,
                            word_count: wordCount ? parseInt(wordCount) : null,
                            rating: rating
                        });
                    }
                }
            }

            return tidyData;
        }

        function analyzeData(data) {
            // è¿‡æ»¤æ‰ç¼ºå¤±å€¼
            const validData = data.filter(d => d.word_count != null && d.rating != null);

            // åŸºç¡€ç»Ÿè®¡
            displayBasicStats(validData);

            // æ•£ç‚¹å›¾ + å›å½’çº¿
            createScatterPlot(validData);

            // ç®±çº¿å›¾ï¼ˆæŒ‰å­—æ•°åˆ†æ¡£ï¼‰
            createBoxPlot(validData);

            // ç›¸å…³æ€§çƒ­åŠ›å›¾
            createHeatmap(validData);

            // æ¨¡å‹å¯¹æ¯”
            createModelComparison(validData);
        }

        function displayBasicStats(data) {
            const wordCounts = data.map(d => d.word_count);
            const ratings = data.map(d => d.rating);

            const stats = {
                'å­—æ•°ç»Ÿè®¡': {
                    'å‡å€¼': mean(wordCounts).toFixed(2),
                    'ä¸­ä½æ•°': median(wordCounts).toFixed(2),
                    'æ ‡å‡†å·®': std(wordCounts).toFixed(2),
                    'æœ€å°å€¼': Math.min(...wordCounts),
                    'æœ€å¤§å€¼': Math.max(...wordCounts)
                },
                'èƒœç‡ç»Ÿè®¡': {
                    'å‡å€¼': mean(ratings).toFixed(2) + '%',
                    'ä¸­ä½æ•°': median(ratings).toFixed(2) + '%',
                    'æ ‡å‡†å·®': std(ratings).toFixed(2) + '%',
                    'æœ€å°å€¼': Math.min(...ratings).toFixed(2) + '%',
                    'æœ€å¤§å€¼': Math.max(...ratings).toFixed(2) + '%'
                },
                'æ•°æ®æ¦‚è§ˆ': {
                    'æ€»æ ·æœ¬æ•°': data.length,
                    'æ¨¡å‹æ•°é‡': new Set(data.map(d => d.model)).size,
                    'Queryæ•°é‡': new Set(data.map(d => d.query)).size
                }
            };

            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';

            Object.entries(stats).forEach(([title, items]) => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <h3>${title}</h3>
                    ${Object.entries(items).map(([label, value]) => `
                        <div class="stat-item">
                            <span class="stat-label">${label}</span>
                            <span class="stat-value">${value}</span>
                        </div>
                    `).join('')}
                `;
                statsGrid.appendChild(card);
            });
        }

        function createScatterPlot(data) {
            const trace = {
                x: data.map(d => d.word_count),
                y: data.map(d => d.rating),
                mode: 'markers',
                type: 'scatter',
                name: 'æ•°æ®ç‚¹',
                marker: {
                    size: 8,
                    color: data.map(d => d.rating),
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: {
                        title: 'èƒœç‡%'
                    }
                },
                text: data.map(d => `æ¨¡å‹: ${d.model}<br>å­—æ•°: ${d.word_count}<br>èƒœç‡: ${d.rating}%`),
                hovertemplate: '%{text}<extra></extra>'
            };

            // è®¡ç®—å›å½’çº¿
            const regression = calculateRegression(
                data.map(d => d.word_count),
                data.map(d => d.rating)
            );

            const regressionTrace = {
                x: regression.x,
                y: regression.y,
                mode: 'lines',
                name: 'å›å½’çº¿',
                line: { color: 'red', width: 2 }
            };

            const layout = {
                title: 'å­—æ•°ä¸èƒœç‡çš„å…³ç³»',
                xaxis: { title: 'å­—æ•°' },
                yaxis: { title: 'èƒœç‡ (%)' },
                hovermode: 'closest'
            };

            Plotly.newPlot('scatterPlot', [trace, regressionTrace], layout);

            // æ˜¾ç¤ºç›¸å…³æ€§æ´å¯Ÿ
            const correlation = calculateCorrelation(
                data.map(d => d.word_count),
                data.map(d => d.rating)
            );

            document.getElementById('correlationInsight').innerHTML = `
                <div class="insight-title">ğŸ“ˆ ç›¸å…³æ€§åˆ†æ</div>
                <div class="insight-text">
                    å­—æ•°ä¸èƒœç‡çš„ç›¸å…³ç³»æ•°ä¸º <strong>${correlation.toFixed(3)}</strong>ã€‚
                    ${Math.abs(correlation) > 0.7 ? 'å­˜åœ¨<strong>å¼º</strong>' : 
                      Math.abs(correlation) > 0.4 ? 'å­˜åœ¨<strong>ä¸­ç­‰</strong>' : 
                      'å­˜åœ¨<strong>å¼±</strong>'}${correlation > 0 ? 'æ­£' : 'è´Ÿ'}ç›¸å…³å…³ç³»ã€‚
                    ${correlation > 0.3 ? 'è¿™è¡¨æ˜å­—æ•°è¶Šå¤šï¼Œèƒœç‡å¾€å¾€è¶Šé«˜ã€‚' : 
                      correlation < -0.3 ? 'è¿™è¡¨æ˜å­—æ•°è¶Šå¤šï¼Œèƒœç‡åè€Œè¶Šä½ã€‚' : 
                      'å­—æ•°ä¸èƒœç‡ä¹‹é—´çš„å…³ç³»ä¸æ˜æ˜¾ã€‚'}
                </div>
            `;
        }

        function createBoxPlot(data) {
            // å°†å­—æ•°åˆ†ä¸º5æ¡£
            const wordCounts = data.map(d => d.word_count);
            const min = Math.min(...wordCounts);
            const max = Math.max(...wordCounts);
            const interval = (max - min) / 5;

            const bins = [];
            for (let i = 0; i < 5; i++) {
                bins.push({
                    label: `${Math.round(min + i * interval)}-${Math.round(min + (i + 1) * interval)}`,
                    min: min + i * interval,
                    max: min + (i + 1) * interval,
                    data: []
                });
            }

            data.forEach(d => {
                for (let i = 0; i < bins.length; i++) {
                    if (d.word_count >= bins[i].min && d.word_count < bins[i].max) {
                        bins[i].data.push(d.rating);
                        break;
                    }
                }
            });

            const traces = bins.map(bin => ({
                y: bin.data,
                type: 'box',
                name: bin.label,
                boxmean: 'sd'
            }));

            const layout = {
                title: 'ä¸åŒå­—æ•°åŒºé—´çš„èƒœç‡åˆ†å¸ƒ',
                xaxis: { title: 'å­—æ•°åŒºé—´' },
                yaxis: { title: 'èƒœç‡ (%)' }
            };

            Plotly.newPlot('boxPlot', traces, layout);

            document.getElementById('distributionInsight').innerHTML = `
                <div class="insight-title">ğŸ“¦ åˆ†å¸ƒåˆ†æ</div>
                <div class="insight-text">
                    ç®±çº¿å›¾å±•ç¤ºäº†ä¸åŒå­—æ•°åŒºé—´çš„èƒœç‡åˆ†å¸ƒæƒ…å†µã€‚ç®±ä½“è¡¨ç¤ºå››åˆ†ä½è·ï¼ˆIQRï¼‰ï¼Œä¸­é—´çš„çº¿è¡¨ç¤ºä¸­ä½æ•°ï¼Œ
                    é’»çŸ³æ ‡è®°è¡¨ç¤ºå‡å€¼ã€‚å¯ä»¥è§‚å¯Ÿåˆ°ä¸åŒå­—æ•°åŒºé—´çš„èƒœç‡ä¸­ä½æ•°å’Œç¦»æ•£ç¨‹åº¦ã€‚
                </div>
            `;
        }

        function createHeatmap(data) {
            // è®¡ç®—ç›¸å…³æ€§çŸ©é˜µ
            const wordCounts = data.map(d => d.word_count);
            const ratings = data.map(d => d.rating);

            const corrMatrix = [
                [1, calculateCorrelation(wordCounts, ratings)],
                [calculateCorrelation(ratings, wordCounts), 1]
            ];

            const trace = {
                z: corrMatrix,
                x: ['å­—æ•°', 'èƒœç‡'],
                y: ['å­—æ•°', 'èƒœç‡'],
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                text: corrMatrix.map(row => row.map(val => val.toFixed(3))),
                texttemplate: '%{text}',
                textfont: { size: 16 }
            };

            const layout = {
                title: 'å˜é‡ç›¸å…³æ€§çƒ­åŠ›å›¾',
                xaxis: { side: 'bottom' },
                yaxis: { autorange: 'reversed' }
            };

            Plotly.newPlot('heatmap', [trace], layout);

            document.getElementById('heatmapInsight').innerHTML = `
                <div class="insight-title">ğŸ”¥ ç›¸å…³æ€§çŸ©é˜µ</div>
                <div class="insight-text">
                    çƒ­åŠ›å›¾æ˜¾ç¤ºäº†å˜é‡ä¹‹é—´çš„ç›¸å…³æ€§å¼ºåº¦ã€‚é¢œè‰²è¶Šçº¢è¡¨ç¤ºæ­£ç›¸å…³è¶Šå¼ºï¼Œè¶Šè“è¡¨ç¤ºè´Ÿç›¸å…³è¶Šå¼ºã€‚
                    å¯¹è§’çº¿ä¸º1è¡¨ç¤ºå˜é‡ä¸è‡ªèº«å®Œå…¨ç›¸å…³ã€‚
                </div>
            `;
        }

        function createModelComparison(data) {
            // æŒ‰æ¨¡å‹åˆ†ç»„ç»Ÿè®¡
            const modelStats = {};
            data.forEach(d => {
                if (!modelStats[d.model]) {
                    modelStats[d.model] = {
                        wordCounts: [],
                        ratings: []
                    };
                }
                modelStats[d.model].wordCounts.push(d.word_count);
                modelStats[d.model].ratings.push(d.rating);
            });

            const models = Object.keys(modelStats);
            const avgWordCounts = models.map(m => mean(modelStats[m].wordCounts));
            const avgRatings = models.map(m => mean(modelStats[m].ratings));

            const trace1 = {
                x: models,
                y: avgWordCounts,
                name: 'å¹³å‡å­—æ•°',
                type: 'bar',
                marker: { color: '#667eea' }
            };

            const trace2 = {
                x: models,
                y: avgRatings,
                name: 'å¹³å‡èƒœç‡',
                type: 'bar',
                yaxis: 'y2',
                marker: { color: '#f093fb' }
            };

            const layout = {
                title: 'ä¸åŒæ¨¡å‹çš„å¹³å‡è¡¨ç°',
                xaxis: { title: 'æ¨¡å‹' },
                yaxis: { title: 'å¹³å‡å­—æ•°' },
                yaxis2: {
                    title: 'å¹³å‡èƒœç‡ (%)',
                    overlaying: 'y',
                    side: 'right'
                },
                barmode: 'group'
            };

            Plotly.newPlot('modelComparison', [trace1, trace2], layout);

            // æ‰¾å‡ºè¡¨ç°æœ€å¥½çš„æ¨¡å‹
            const bestModel = models[avgRatings.indexOf(Math.max(...avgRatings))];
            const mostVerbose = models[avgWordCounts.indexOf(Math.max(...avgWordCounts))];

            document.getElementById('modelInsight').innerHTML = `
                <div class="insight-title">ğŸ† æ¨¡å‹è¡¨ç°</div>
                <div class="insight-text">
                    <strong>${bestModel}</strong> çš„å¹³å‡èƒœç‡æœ€é«˜ï¼ˆ${Math.max(...avgRatings).toFixed(2)}%ï¼‰ï¼Œ
                    <strong>${mostVerbose}</strong> çš„å¹³å‡å­—æ•°æœ€å¤šï¼ˆ${Math.max(...avgWordCounts).toFixed(0)}å­—ï¼‰ã€‚
                    ${bestModel === mostVerbose ? 'æœ€ä½³æ¨¡å‹åŒæ—¶ä¹Ÿæ˜¯æœ€è¯¦ç»†çš„æ¨¡å‹ã€‚' : ''}
                </div>
            `;
        }

        // ç»Ÿè®¡å‡½æ•°
        function mean(arr) {
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function median(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function std(arr) {
            const avg = mean(arr);
            const squareDiffs = arr.map(value => Math.pow(value - avg, 2));
            return Math.sqrt(mean(squareDiffs));
        }

        function calculateCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            return numerator / denominator;
        }

        function calculateRegression(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            const minX = Math.min(...x);
            const maxX = Math.max(...x);
            const regressionX = [minX, maxX];
            const regressionY = regressionX.map(xi => slope * xi + intercept);

            return { x: regressionX, y: regressionY, slope, intercept };
        }
    </script>
</body>
</html>

